{"version":3,"sources":["webpack:///webpack/bootstrap 2550a2300cf067902545","webpack:///./src/components/x-app.js","webpack:///./node_modules/hyperhtml-element/index.js","webpack:///./node_modules/hyperhtml/hyperhtml.js","webpack:///./src/components/x-button.js","webpack:///./node_modules/rxjs-es/util/root.js","webpack:///./node_modules/rxjs-es/util/isFunction.js","webpack:///./node_modules/rxjs-es/util/errorObject.js","webpack:///./node_modules/rxjs-es/symbol/rxSubscriber.js","webpack:///./node_modules/rxjs-es/Observable.js","webpack:///(webpack)/buildin/global.js","webpack:///./node_modules/rxjs-es/util/toSubscriber.js","webpack:///./node_modules/rxjs-es/Subscriber.js","webpack:///./node_modules/rxjs-es/Subscription.js","webpack:///./node_modules/rxjs-es/util/isArray.js","webpack:///./node_modules/rxjs-es/util/isObject.js","webpack:///./node_modules/rxjs-es/util/tryCatch.js","webpack:///./node_modules/rxjs-es/util/UnsubscriptionError.js","webpack:///./node_modules/rxjs-es/Observer.js","webpack:///./node_modules/rxjs-es/symbol/observable.js","webpack:///./node_modules/rxjs-es/add/observable/fromEvent.js","webpack:///./node_modules/rxjs-es/observable/fromEvent.js","webpack:///./node_modules/rxjs-es/observable/FromEventObservable.js","webpack:///./node_modules/rxjs-es/add/operator/map.js","webpack:///./node_modules/rxjs-es/operator/map.js"],"names":["__webpack_require__","moduleId","installedModules","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","XApp","__WEBPACK_IMPORTED_MODULE_0_hyperhtml_element___default","a","observedAttributes","[object Object]","this","number","Math","random","prev","curr","render","value","html","define","HyperHTMLElement","__init","HTMLElement","Class","proto","forEach","replace","$0","$1","toUpperCase","getAttribute","setAttribute","onChanged","attributeChangedCallback","hasChange","created","writable","apply","arguments","onConnected","connectedCallback","hasConnect","event","type","customElements","__hyperHTML","hyperHTML","bind","shadowRoot","_shadowRoot","o_O","globalDocument","template","hyper","hypers","FF","unique","upgrade","set","update","updates","indexOfDifferences","b","aLength","length","bLength","populateNode","parent","child","nodeType","ELEMENT_NODE","childNodes","removeNodeList","resetAndPopulate","DOCUMENT_FRAGMENT_NODE","TEXT_NODE","textContent","list","startIndex","parentNode","removeChild","appendChild","updateViaArray","node","fragment","emptyFragment","appendNodes","slice","setAnyContent","any","innerHTML","children","isArray","join","concat","isPromise_ish","Promise","all","then","attribute","removeAttributes","oldValue","ownerElement","isEvent","test","isSpecial","OWNER_SVG_ELEMENT","SHOULD_USE_ATTRIBUTE","push","newValue","removeEventListener","addEventListener","setTextContent","setVirtualContent","anyVirtual","createFragment","insertBefore","updateVirtualNodes","attributesSeeker","paths","IE","UID","UIDC","attributes","Path","IEAttributes","shift","commentsSeeker","text","COMMENT_NODE","createText","replaceChild","nodeName","fnEscape","oEscape","createContent","content","trim","createDocumentFragment","document","createSVGFragment","createHTMLFragment","ownerDocument","container","createElement","hasContent","needsTableWrap","selector","RegExp","querySelectorAll","createElementNS","SVG_NAMESPACE","createTextNode","discoverNode","virtual","info","target","path","virtualNode","getNode","hasAttribute","before","getTextContent","after","firstChild","getChildren","virtualChildren","previousElementSibling","indexOf","nextElementSibling","createComment","removePreviousText","direction","method","unshift","removeAttributeList","removeAttribute","previousSibling","setContent","splice","createPath","createTemplate","no","comments","templates","ATTRIBUTE_NODE","createUpdates","discoverUpdates","notAdopting","cloneNode","wireContent","setup","adopter","statics","args","adopt","wireWeakly","obj","wire","wires","id","escape","reEscape","templateObjects","EXPANDO","Date","featureFragment","navigator","userAgent","parseFloat","WK","&","<",">","'","\"","$WeakMap","WeakMap","$Map","Map","k","v","Array","toString","create","key","append","j","$2","nextSibling","undefined","clone","XButton","attachShadow","mode","__WEBPACK_IMPORTED_MODULE_1_rxjs_es_Observable__","fromEvent","map","evt","console","log","x","clientX","y","clientY","data","JSON","stringify","e","__webpack_exports__","root","objectTypes","boolean","function","string","self","window","freeGlobal","global","errorObject","Symbol","$$rxSubscriber","for","Observable","subscribe","_isScalar","_subscribe","operator","observable","source","observerOrNext","error","complete","sink","__WEBPACK_IMPORTED_MODULE_1__util_toSubscriber__","add","syncErrorThrowable","syncErrorThrown","syncErrorValue","next","PromiseCtor","__WEBPACK_IMPORTED_MODULE_0__util_root__","Rx","config","Error","resolve","reject","subscription","err","unsubscribe","subscriber","__WEBPACK_IMPORTED_MODULE_2__symbol_observable__","g","Function","eval","nextOrObserver","__WEBPACK_IMPORTED_MODULE_0__Subscriber__","__WEBPACK_IMPORTED_MODULE_1__symbol_rxSubscriber__","Subscriber","__WEBPACK_IMPORTED_MODULE_1__Subscription__","destinationOrNext","super","isStopped","destination","__WEBPACK_IMPORTED_MODULE_2__Observer__","SafeSubscriber","__WEBPACK_IMPORTED_MODULE_3__symbol_rxSubscriber__","_next","_error","_complete","closed","_parent","context","__WEBPACK_IMPORTED_MODULE_0__util_isFunction__","_context","__tryOrSetError","__tryOrUnsub","fn","Subscription","_unsubscribe","errors","hasErrors","_subscriptions","__WEBPACK_IMPORTED_MODULE_2__util_isFunction__","__WEBPACK_IMPORTED_MODULE_3__util_tryCatch__","__WEBPACK_IMPORTED_MODULE_4__util_errorObject__","__WEBPACK_IMPORTED_MODULE_0__util_isArray__","index","len","sub","__WEBPACK_IMPORTED_MODULE_1__util_isObject__","__WEBPACK_IMPORTED_MODULE_5__util_UnsubscriptionError__","teardown","EMPTY","subscriptions","subscriptionIndex","empty","tryCatcher","tryCatchTarget","__WEBPACK_IMPORTED_MODULE_0__errorObject__","UnsubscriptionError","stack","message","$$observable","getSymbolObservable","__WEBPACK_IMPORTED_MODULE_0__Observable__","__WEBPACK_IMPORTED_MODULE_1__observable_fromEvent__","isNodeStyleEventEmmitter","sourceObj","addListener","removeListener","isJQueryStyleEventEmitter","on","off","isNodeList","isHTMLCollection","isEventTarget","FromEventObservable","eventName","options","handler","setupSubscription","__WEBPACK_IMPORTED_MODULE_4__Subscription__","result","__WEBPACK_IMPORTED_MODULE_1__util_tryCatch__","__WEBPACK_IMPORTED_MODULE_3__util_errorObject__","__WEBPACK_IMPORTED_MODULE_1__operator_map__","project","thisArg","TypeError","lift","MapOperator","MapSubscriber","count"],"mappings":"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","file":"app.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 2550a2300cf067902545","'use strict';\n\nimport HyperHTMLElement from 'hyperhtml-element';\nimport './x-button';\n\nclass XApp extends HyperHTMLElement {\n\n  static get observedAttributes() { return ['number']; }\n\n  created() {\n    this.number = Math.random() * 100;\n  }\n\n  attributeChangedCallback(name, prev, curr) {\n    this.render();\n  }\n\n  random(value = 100){\n    this.number = Math.random() * value;\n  }\n\n  render(){\n    return this.html`<section>\n      <p>Test with some random number: <strong>${this.number}</strong></p>\n      <x-button>Click me!</x-button>\n    </section>`;\n  }\n\n}\n\nXApp.define('x-app');\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/components/x-app.js\n// module id = 2\n// module chunks = 0","const HyperHTMLElement = (defineProperty => {\n  /*! (C) 2017 Andrea Giammarchi - ISC Style License */\n  const __init = {value: false};\n  return class HyperHTMLElement extends HTMLElement {\n\n    // define a custom-element in the CustomElementsRegistry\n    // class MyEl extends HyperHTMLElement {}\n    // MyEl.define('my-el');\n    static define(name) {\n      const Class = this;\n      const proto = Class.prototype;\n\n      // if observedAttributes contains attributes to observe\n      // HyperHTMLElement will directly reflect get/setAttribute\n      // operation once these attributes are used, example:\n      // el.observed = 123;\n      // will automatically do\n      // el.setAttribute('observed', 123);\n      // triggering also the attributeChangedCallback\n      (Class.observedAttributes || []).forEach(name => {\n        if (!(name in proto)) defineProperty(\n          proto,\n          name.replace(/-([a-z])/g, ($0, $1) => $1.toUpperCase()),\n          {\n            configurable: true,\n            get() { return this.getAttribute(name); },\n            set(value) { this.setAttribute(name, value); }\n          }\n        );\n      });\n\n      const onChanged = proto.attributeChangedCallback;\n      const hasChange = !!onChanged;\n\n      // created() {} is the entry point to do whatever you want.\n      // Once the node is live and upgraded as Custom Element.\n      // This method grants to be triggered at the right time,\n      // which is always once, and right before either\n      // attributeChangedCallback or connectedCallback\n      const created = proto.created;\n      if (created) {\n        // used to ensure create() is called once and once only\n        defineProperty(\n          proto,\n          '__init',\n          {\n            configurable: true,\n            writable: true,\n            value: true\n          }\n        );\n\n        // ‚ö†Ô∏è if you need to overwrite/change attributeChangedCallback method\n        //    at runtime after class definition, be sure you do so\n        //    via Object.defineProperty to preserve its non-enumerable nature.\n        defineProperty(\n          proto,\n          'attributeChangedCallback',\n          {\n            configurable: true,\n            value(name, prev, curr) {\n              if (this.__init) {\n                created.call(defineProperty(this, '__init', __init));\n              }\n              // ensure setting same value twice\n              // won't trigger twice attributeChangedCallback\n              if (hasChange && prev !== curr) {\n                onChanged.apply(this, arguments);\n              }\n            }\n          }\n        );\n\n        // ‚ö†Ô∏è if you need to overwrite/change connectedCallback method\n        //    at runtime after class definition, be sure you do so\n        //    via Object.defineProperty to preserve its non-enumerable nature.\n        const onConnected = proto.connectedCallback;\n        const hasConnect = !!onConnected;\n        defineProperty(\n          proto,\n          'connectedCallback',\n          {\n            configurable: true,\n            value() {\n              if (this.__init) {\n                created.call(defineProperty(this, '__init', __init));\n              }\n              if (hasConnect) {\n                onConnected.apply(this, arguments);\n              }\n            }\n          }\n        );\n      } else if (hasChange) {\n        // ‚ö†Ô∏è if you need to overwrite/change attributeChangedCallback method\n        //    at runtime after class definition, be sure you do so\n        //    via Object.defineProperty to preserve its non-enumerable nature.\n        defineProperty(\n          proto,\n          'attributeChangedCallback',\n          {\n            configurable: true,\n            value(name, prev, curr) {\n              // ensure setting same value twice\n              // won't trigger twice attributeChangedCallback\n              if (prev !== curr) {\n                onChanged.apply(this, arguments);\n              }\n            }\n          }\n        );\n      }\n\n      // whenever you want to directly use the component itself\n      // as EventListener, you can pass it directly.\n      // https://medium.com/@WebReflection/dom-handleevent-a-cross-platform-standard-since-year-2000-5bf17287fd38\n      //  class Reactive extends HyperHTMLElement {\n      //    oninput(e) { console.log(this, 'changed', e.target.value); }\n      //    render() { this.html`<input oninput=\"${this}\">`; }\n      //  }\n      if (!('handleEvent' in proto)) {\n        // ‚ö†Ô∏è if you need to overwrite/change handleEvent method\n        //    at runtime after class definition, be sure you do so\n        //    via Object.defineProperty to preserve its non-enumerable nature.\n        defineProperty(\n          proto,\n          'handleEvent',\n          {\n            configurable: true,\n            value(event) {\n              this['on' + event.type](event);\n            }\n          }\n        );\n      }\n      customElements.define(name, Class);\n      return Class;\n    }\n\n    // lazily bind once hyperHTML logic\n    // to either the shadowRoot, if present and open,\n    // the _shadowRoot property, if set due closed shadow root,\n    // or the custom-element itself if no Shadow DOM is used.\n    get html() {\n      // ‚ö†Ô∏è defineProperty(this, 'html', {...}) would be the intent\n      //    then you have to deal with IE11 and broken ES5 implementations\n      //    where a getter in the prototype curses forever instances\n      //    properties definition.\n      return this.__hyperHTML || defineProperty(this, '__hyperHTML', {\n        configurable: true,\n        value: hyperHTML.bind(\n          // in case of Shadow DOM {mode: \"open\"}, use it\n          this.shadowRoot ||\n          // in case of Shadow DOM {mode: \"close\"}, use it\n          // this needs the following reference created upfront\n          // this._shadowRoot = this.attachShadow({mode: \"close\"});\n          this._shadowRoot ||\n          // if no Shadow DOM is used, simply use the component\n          // as container for its own content (it just works too)\n          this\n        )\n      }).__hyperHTML;\n    }\n\n  };\n\n})(Object.defineProperty);\n\ntry {\n  // try to export HyperHTMLElement as module\n  module.exports = HyperHTMLElement;\n  // if possible, also eventually require hyperHTML\n  // and hoist it on the current scope\n  var hyperHTML = hyperHTML || require('hyperhtml');\n} catch(o_O) {}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/hyperhtml-element/index.js\n// module id = 3\n// module chunks = 0","var hyperHTML = (function (globalDocument) {'use strict';\n\n  /*! (c) 2017 Andrea Giammarchi @WebReflection, (MIT) */\n\n  // ---------------------------------------------\n  // hyperHTML Public API\n  // ---------------------------------------------\n\n  // The document must be swap-able at runtime.\n  // Needed by both basicHTML and nativeHTML\n  hyperHTML.document = globalDocument;\n\n  // hyperHTML.bind(el) ‚ö°Ô∏è\n  function hyperHTML(template) {\n    var hyper = hypers.get(this);\n    if (\n      !hyper ||\n      hyper.template !== (FF ? unique(template) : template)\n    ) {\n      hyper = upgrade.apply(this, arguments);\n      hypers.set(this, hyper);\n    }\n    update.apply(hyper.updates, arguments);\n    return this;\n  }\n\n  // hyperHTML.adopt(el) üê£\n  hyperHTML.adopt = function adopt(node) {\n    return function () {\n      notAdopting = false;\n      hyperHTML.apply(node, arguments);\n      notAdopting = true;\n      return node;\n    };\n  };\n\n  // hyperHTML.escape('<html>') => '&lt;text&gt;'\n  hyperHTML.escape = function escape(html) {\n    return html.replace(reEscape, fnEscape);\n  };\n\n  // hyperHTML.wire(obj, 'type:ID') ‚û∞\n  hyperHTML.wire = function wire(obj, type) {\n    return arguments.length < 1 ?\n      wireContent('html') :\n      (obj == null ?\n        wireContent(type || 'html') :\n        wireWeakly(obj, type || 'html')\n      );\n  };\n\n  // - - - - - - - - - - - - - - - - - - - - - - -\n\n  // ---------------------------------------------\n  // Constants\n  // ---------------------------------------------\n\n  // Node.CONSTANTS\n  // without assuming Node is globally available\n  // since this project is used on the backend too\n  var ELEMENT_NODE = 1;\n  var ATTRIBUTE_NODE = 2;\n  var TEXT_NODE = 3;\n  var COMMENT_NODE = 8;\n  var DOCUMENT_FRAGMENT_NODE = 11;\n\n  // SVG related\n  var OWNER_SVG_ELEMENT = 'ownerSVGElement';\n  var SVG_NAMESPACE = 'http://www.w3.org/2000/svg';\n\n  var SHOULD_USE_ATTRIBUTE = /^style$/i;\n  var EXPANDO = '_hyper_html: ';\n  var UID = EXPANDO + ((Math.random() * new Date) | 0) + ';';\n  var UIDC = '<!--' + UID + '-->';\n\n  // ---------------------------------------------\n  // DOM Manipulation\n  // ---------------------------------------------\n\n  // return -1 if no differences are found\n  // the index where differences starts otherwise\n  function indexOfDifferences(a, b) {\n    var\n      i = 0,\n      aLength = a.length,\n      bLength = b.length\n    ;\n    while (i < aLength) {\n      if (i < bLength && a[i] === b[i]) i++;\n      else return i;\n    }\n    return i === bLength ? -1 : i;\n  }\n\n  // accordingly with the content type\n  // it replace the content of a node\n  // with the give child\n  function populateNode(parent, child) {\n    switch (child.nodeType) {\n      case ELEMENT_NODE:\n        var childNodes = parent.childNodes;\n        if (childNodes[0] === child) {\n          removeNodeList(childNodes, 1);\n          break;\n        }\n        resetAndPopulate(parent, child);\n        break;\n      case DOCUMENT_FRAGMENT_NODE:\n        if (indexOfDifferences(parent.childNodes, child.childNodes) !== -1) {\n          resetAndPopulate(parent, child);\n        }\n        break;\n      case TEXT_NODE:\n        parent.textContent = child.textContent;\n        break;\n    }\n  }\n\n  // remove a list of nodes from startIndex to list.length\n  function removeNodeList(list, startIndex) {\n    var length = list.length, child;\n    while (startIndex < length--) {\n      child = list[length];\n      child.parentNode.removeChild(child);\n    }\n  }\n\n  // erase a node content and populate it\n  function resetAndPopulate(parent, child) {\n    parent.textContent = '';\n    parent.appendChild(child);\n  }\n\n  // append childNodes to a node from a specific index\n  function updateViaArray(node, childNodes, i) {\n    var fragment = emptyFragment(node);\n    if (i !== 0) {\n      removeNodeList(node.childNodes, i);\n      appendNodes(fragment, childNodes.slice(i));\n      node.appendChild(fragment);\n    } else {\n      appendNodes(fragment, childNodes);\n      resetAndPopulate(node, fragment);\n    }\n  }\n\n  // ---------------------------------------------\n  // hyperHTML Operations\n  // ---------------------------------------------\n\n  // `<div>${'any'}</div>`\n  function setAnyContent(node) {\n    return function any(value) {\n      switch (typeof value) {\n        case 'string':\n        case 'number':\n        case 'boolean':\n          node.innerHTML = value;\n          break;\n        case 'function':\n          any(value(node, node.children, 0));\n          break;\n        default:\n          if (isArray(value)) {\n            var i, length = value.length;\n            if (length === 1) {\n              any(value[0]);\n            } else {\n              switch (length === 0 ? '' : typeof value[0]) {\n                case 'string':\n                case 'number':\n                case 'boolean':\n                  any(value.join(''));\n                  break;\n                case 'function':\n                  var children = slice.call(node.children);\n                  for (i = 0, length = value.length; i < length; i++) {\n                    value[i] = value[i](node, children, i);\n                  }\n                  removeNodeList(children, i);\n                  any(value.concat.apply([], value));\n                  break;\n                case 'object':\n                  if (isArray(value[0])) {\n                    value = value.concat.apply([], value);\n                  }\n                  if (isPromise_ish(value[0])) {\n                    Promise.all(value).then(any);\n                    break;\n                  }\n                default:\n                  i = indexOfDifferences(node.childNodes, value);\n                  if (i !== -1) updateViaArray(node, value, i);\n                  break;\n              }\n            }\n          } else if (isPromise_ish(value)) {\n            value.then(any);\n          } else {\n            populateNode(node, value);\n          }\n          break;\n      }\n    };\n  }\n\n  // `<div class=\"${'attr'}\"></div>`\n  // `<div onclick=\"${function () {... }}\"></div>`\n  // `<div onclick=\"${{handleEvent(){ ... }}}\"></div>`\n  // `<div contenteditable=\"${true}\"></div>`\n  function setAttribute(attribute, removeAttributes) {\n    var\n      name = attribute.name,\n      node = attribute.ownerElement,\n      isEvent = /^on/.test(name),\n      isSpecial = name in node && !(\n                    // always use set attribute with SVGs\n                    OWNER_SVG_ELEMENT in node ||\n                    SHOULD_USE_ATTRIBUTE.test(name)\n                  ),\n      type = isEvent ? name.slice(2) : '',\n      oldValue\n    ;\n    if (isSpecial || isEvent) removeAttributes.push(node, name);\n    return isEvent ?\n      function eventAttr(newValue) {\n        if (oldValue !== newValue) {\n          if (oldValue) node.removeEventListener(type, oldValue, false);\n          oldValue = newValue;\n          if (newValue) node.addEventListener(type, newValue, false);\n        }\n      } :\n      (isSpecial ?\n        function specialAttr(newValue) {\n          if (oldValue !== newValue) {\n            oldValue = newValue;\n            // WebKit moves the cursor if input.value\n            // is set again, even if same value\n            if (node[name] !== newValue) {\n              node[name] = newValue;\n            }\n          }\n        } :\n        function normalAttr(newValue) {\n          if (oldValue !== newValue) {\n            oldValue = newValue;\n            // WebKit moves the cursor if input.value\n            // is set again, even if same value\n            if (attribute.value !== newValue) {\n              attribute.value = newValue;\n            }\n          }\n        }\n      );\n  }\n\n  // `<div> ${'text'} </div>`\n  function setTextContent(node) {\n    var oldValue;\n    return function text(newValue) {\n      if (oldValue !== newValue) {\n        oldValue = newValue;\n        node.textContent = newValue;\n      }\n    };\n  }\n\n  // `<li>a</li>${'virtual'}<li>c</li>`\n  function setVirtualContent(node, childNodes) {\n    return function anyVirtual(value) {\n      switch (typeof value) {\n        case 'string':\n        case 'number':\n        case 'boolean':\n          removeNodeList(childNodes, 0);\n          var fragment = createFragment(node, value);\n          childNodes = slice.call(fragment.childNodes);\n          node.parentNode.insertBefore(fragment, node);\n          break;\n        case 'function':\n          anyVirtual(value(node.parentNode, childNodes, 0));\n          break;\n        default:\n          if (isArray(value)) {\n            if (value.length === 0) {\n              removeNodeList(childNodes, 0);\n              childNodes = [];\n            } else {\n              switch (typeof value[0]) {\n                case 'string':\n                case 'number':\n                case 'boolean':\n                  anyVirtual(value.join(''));\n                  break;\n                case 'function':\n                  var parentNode = node.parentNode;\n                  for (var i = 0, length = value.length; i < length; i++) {\n                    value[i] = value[i](parentNode, childNodes, i);\n                  }\n                  anyVirtual(value.concat.apply([], value));\n                  break;\n                case 'object':\n                  if (isArray(value[0])) {\n                    value = value.concat.apply([], value);\n                  }\n                  if (isPromise_ish(value[0])) {\n                    Promise.all(value).then(anyVirtual);\n                    break;\n                  }\n                default:\n                  updateVirtualNodes(node, childNodes, value);\n                  break;\n              }\n            }\n          } else if (isPromise_ish(value)) {\n            value.then(anyVirtual);\n          } else {\n            updateVirtualNodes(\n              node,\n              childNodes,\n              value.nodeType === DOCUMENT_FRAGMENT_NODE ?\n                slice.call(value.childNodes) :\n                [value]\n            );\n          }\n          break;\n      }\n    };\n  }\n\n  // ---------------------------------------------\n  // DOM Traversing\n  // ---------------------------------------------\n\n  // look for attributes that contains the comment text\n  function attributesSeeker(node, paths) {\n    for (var\n      attribute,\n      value = IE ? UID : UIDC,\n      attributes = node.attributes,\n      i = 0, length = attributes.length;\n      i < length; i++\n    ) {\n      attribute = attributes[i];\n      if (attribute.value === value) {\n        paths.push(\n          Path(\n            'attr',\n            // with IE the order doesn't really matter\n            // as long as the right attribute is addressed\n            IE ?\n              node.attributes[IEAttributes.shift()] :\n              attribute\n          )\n        );\n      }\n    }\n  }\n\n  // walk the fragment tree in search of comments\n  function commentsSeeker(node, paths) {\n    for (var\n      child, text,\n      childNodes = node.childNodes,\n      length = childNodes.length,\n      i = 0; i < length; i++\n    ) {\n      child = childNodes[i];\n      switch (child.nodeType) {\n        case ELEMENT_NODE:\n          attributesSeeker(child, paths);\n          commentsSeeker(child, paths);\n          break;\n        case COMMENT_NODE:\n          if (child.textContent === UID) {\n            if (length === 1) {\n              paths.push(Path('any', node));\n            } else if (\n              (i < 1 || childNodes[i - 1].nodeType === ELEMENT_NODE) &&\n              (i + 1 === length || childNodes[i + 1].nodeType === ELEMENT_NODE)\n            ) {\n              paths.push(Path('virtual', child));\n            } else {\n              text = createText(child, '');\n              child.parentNode.replaceChild(text, child);\n              paths.push(Path('text', text));\n            }\n          }\n          break;\n        case TEXT_NODE:\n          if (SHOULD_USE_ATTRIBUTE.test(node.nodeName) && child.textContent === UIDC) {\n            paths.push(Path('text', node));\n          }\n          break;\n      }\n    }\n  }\n\n  // ---------------------------------------------\n  // Features detection / ugly UA sniffs\n  // ---------------------------------------------\n  var featureFragment = createDocumentFragment(globalDocument);\n\n  // Firefox < 55 has non standard template literals.\n  // https://bugzilla.mozilla.org/show_bug.cgi?id=1108941\n  // TODO: is there any better way to feature detect this ?\n  var FF = typeof navigator === 'object' &&\n            /Firefox\\/(\\d+)/.test(navigator.userAgent) &&\n            parseFloat(RegExp.$1) < 55;\n\n  // If attributes order is shuffled, threat the browser differently\n  // Usually this is a well known IE only limitation but some older FF does the same.\n  var IE =  (function () {\n              var p  = globalDocument.createElement('p');\n              p.innerHTML = '<i data-i=\"\" class=\"\"></i>';\n              return /class/i.test(p.firstChild.attributes[0].name);\n            }());\n\n\n  // beside IE, old WebKit browsers don't have `children` in DocumentFragment\n  var WK = !('children' in featureFragment);\n\n  // ---------------------------------------------\n  // Helpers\n  // ---------------------------------------------\n\n  // used to convert childNodes to Array\n  var slice = [].slice;\n\n  // used to sanitize html\n  var reEscape = /[&<>'\"]/g;\n  var oEscape = {\n    '&': '&amp;',\n    '<': '&lt;',\n    '>': '&gt;',\n    \"'\": '&#39;',\n    '\"': '&quot;'\n  };\n  function fnEscape(m) {\n    return oEscape[m];\n  }\n\n  // return a single node or an Array or nodes\n  function createContent(node) {\n    for (var\n      child,\n      content = [],\n      childNodes = node.childNodes,\n      i = 0,\n      length = childNodes.length;\n      i < length; i++\n    ) {\n      child = childNodes[i];\n      if (\n        child.nodeType === ELEMENT_NODE ||\n        trim.call(child.textContent).length !== 0\n      ) {\n        content.push(child);\n      }\n    }\n    return content.length === 1 ? content[0] : content;\n  }\n\n  // just a minifier friendly indirection\n  function createDocumentFragment(document) {\n    return document.createDocumentFragment();\n  }\n\n  // given a node, inject some html and return\n  // the resulting template document fragment\n  function createFragment(node, html) {\n    return (\n      OWNER_SVG_ELEMENT in node ?\n        createSVGFragment :\n        createHTMLFragment\n    )(node, html);\n  }\n\n  // create fragment for HTML\n  function createHTMLFragment(node, html) {\n    var fragment;\n    var document = node.ownerDocument;\n    var container = document.createElement('template');\n    var hasContent = 'content' in container;\n    var needsTableWrap = false;\n    if (!hasContent) {\n      // DO NOT MOVE THE FOLLOWING LINE ELSEWHERE\n      fragment = createDocumentFragment(document);\n      // (a jsdom + nodejs tests coverage gotcha)\n\n      // el.innerHTML = '<td></td>'; is not possible\n      // if the content is a partial internal table content\n      // it needs to be wrapped around once injected.\n      // HTMLTemplateElement does not suffer this issue.\n      needsTableWrap = /^[^\\S]*?<(t(?:head|body|foot|r|d|h))/i.test(html);\n    }\n    if (needsTableWrap) {\n      // secure the RegExp.$1 result ASAP to avoid issues\n      // in case a non-browser DOM library uses RegExp internally\n      // when HTML content is injected (basicHTML / jsdom / others...)\n      var selector = RegExp.$1;\n      container.innerHTML = '<table>' + html + '</table>';\n      appendNodes(fragment, slice.call(container.querySelectorAll(selector)));\n    } else {\n      container.innerHTML = html;\n      if (hasContent) {\n        fragment = container.content;\n      } else {\n        appendNodes(fragment, slice.call(container.childNodes));\n      }\n    }\n    return fragment;\n  }\n\n  // create a fragment for SVG\n  function createSVGFragment(node, html) {\n    var document = node.ownerDocument;\n    var fragment = createDocumentFragment(document);\n    var container = document.createElementNS(SVG_NAMESPACE, 'svg');\n    container.innerHTML = html;\n    appendNodes(fragment, slice.call(container.childNodes));\n    return fragment;\n  }\n\n  // given a node, it does what is says\n  function createText(node, text) {\n    return node.ownerDocument.createTextNode(text);\n  }\n\n  // given an info, tries to find out the best option\n  // to replace or update the content\n  function discoverNode(parentNode, virtual, info, childNodes) {\n    for (var\n      target = parentNode,\n      document = parentNode.ownerDocument,\n      path = info.path,\n      virtualNode = getNode(virtual, path),\n      i = 0,\n      length = path.length;\n      i < length; i++\n    ) {\n      switch (path[i++]) {\n        case 'attributes':\n          var name = virtualNode.name;\n          if (!parentNode.hasAttribute(name)) {\n            parentNode.setAttribute(name, '');\n          }\n          target = parentNode.attributes[name];\n          break;\n        case 'childNodes':\n          switch (info.type) {\n            // TODO: supports multiple text per element ?\n            case 'text':\n              var before = getTextContent(virtualNode, 'previous');\n              var after = getTextContent(virtualNode, 'next');\n              do {\n                target = parentNode.firstChild;\n                if (target && target.nodeType === TEXT_NODE) {\n                  parentNode.removeChild(target);\n                } else {\n                  break;\n                }\n              } while (target);\n              var fragment = createDocumentFragment(document);\n              if (before.length) {\n                fragment.appendChild(createText(parentNode, before));\n              }\n              target = fragment.appendChild(createText(parentNode, ''));\n              if (after.length) {\n                fragment.appendChild(createText(parentNode, after));\n              }\n              parentNode.insertBefore(fragment, parentNode.firstChild);\n              break;\n            // TODO: supports multiple virtual content per element ?\n            case 'virtual':\n              var children = getChildren(parentNode);\n              var virtualChildren = getChildren(virtualNode.parentNode);\n              target = previousElementSibling(virtualNode);\n              var before = target ? (path.indexOf.call(virtualChildren, target) + 1) : -1;\n              target = nextElementSibling(virtualNode);\n              var after = target ? path.indexOf.call(virtualChildren, target) : -1;\n              target = document.createComment(UID);\n              switch (true) {\n                // `${'virtual'}` is actually resolved as `${'any'}`\n                // case before < 0 && after < 0: before = 0;\n\n                // `</a>${'virtual'}`\n                case after < 0:\n                  after = children.length;\n                  break;\n                // `${'virtual'}<b>`\n                case before < 0:\n                  before = 0;\n                // `</a>${'virtual'}<b>`\n                default:\n                  after = -(virtualChildren.length - after);\n                  break;\n              }\n              childNodes.push.apply(\n                childNodes,\n                slice.call(children, before, after)\n              );\n              parentNode.insertBefore(\n                target,\n                childNodes.length ?\n                  nextElementSibling(childNodes[childNodes.length - 1]) :\n                  slice.call(children, after)[0]\n              );\n              if (childNodes.length === 0) {\n                removePreviousText(parentNode, target);\n              }\n              break;\n          }\n          break;\n        default:\n          // if the node is not there, create it\n          target = getChildren(parentNode)[path[i]] ||\n                    parentNode.appendChild(\n                      parentNode.ownerDocument.createElement(\n                        getNode(virtual, path.slice(0, i + 1)).nodeName\n                      )\n                    );\n          parentNode = target;\n          break;\n      }\n    }\n    return target;\n  }\n\n  // create an empty fragment from a generic node\n  function emptyFragment(node) {\n    return createDocumentFragment(node.ownerDocument);\n  }\n\n  // given a node, returns text content before it or after it\n  function getTextContent(node, direction) {\n    var content = [];\n    var method = direction === 'next' ?\n        content.push : content.unshift;\n    do {\n      node = node[direction + 'Sibling'];\n      if (node && node.nodeType === TEXT_NODE) {\n        method.call(content, node.textContent);\n      } else {\n        return content.join('');\n      }\n    } while (true);\n  }\n\n  // quick and dirty Promise check\n  function isPromise_ish(value) {\n    return value != null && 'then' in value;\n  }\n\n  // remove a list of [node, attribute]\n  function removeAttributeList(list) {\n    for (var i = 0, length = list.length; i < length; i++) {\n      list[i++].removeAttribute(list[i]);\n    }\n  }\n\n  // remove all text nodes from a virtual space\n  function removePreviousText(parentNode, node) {\n    var previousSibling = node.previousSibling;\n    if (previousSibling && previousSibling.nodeType === TEXT_NODE) {\n      parentNode.removeChild(previousSibling);\n      removePreviousText(parentNode, node);\n    }\n  }\n\n  // specify the content to update\n  function setContent(type, target, removeAttributes, childNodes) {\n    var update;\n    switch (type) {\n      case 'any':\n        update = setAnyContent(target);\n        break;\n      case 'attr':\n        update = setAttribute(target, removeAttributes);\n        break;\n      case 'text':\n        update = setTextContent(target);\n        break;\n      case 'virtual':\n        update = setVirtualContent(target, childNodes);\n        break;\n    }\n    return update;\n  }\n\n  // update partially or fully the list of virtual nodes\n  // it modifies in place the childNodes list if necessary\n  function updateVirtualNodes(node, childNodes, value) {\n    var i = indexOfDifferences(childNodes, value);\n    if (i !== -1) {\n      var fragment = emptyFragment(node);\n      removeNodeList(childNodes, i);\n      childNodes.splice(i);\n      value = value.slice(i);\n      appendNodes(fragment, value);\n      node.parentNode.insertBefore(fragment, node);\n      childNodes.push.apply(childNodes, value);\n    }\n  }\n\n  // used for common path creation.\n  function Path(type, node) {\n    return {type: type, path: createPath(node)};\n  }\n\n  // ---------------------------------------------\n  // Hybrid Shims\n  // ---------------------------------------------\n\n  // WeakMap with partial EXPANDO fallback\n  var $WeakMap = typeof WeakMap === typeof $WeakMap ?\n      function () {\n        return {\n          get: function (obj) { return obj[EXPANDO]; },\n          set: function (obj, value) {\n            Object.defineProperty(obj, EXPANDO, {\n              configurable: true,\n              value: value\n            });\n          }\n        };\n      } :\n      WeakMap;\n\n  // Map with partial double Array fallback\n  var $Map = typeof Map === typeof $Map ?\n      function () {\n        var k = [], v = [];\n        return {\n          get: function (obj) {\n            return v[k.indexOf(obj)];\n          },\n          // being used with unique template literals\n          // there is never a case when a value is overwritten\n          // no need to check upfront for the indexOf\n          set: function (obj, value) {\n            v[k.push(obj) - 1] = value;\n          }\n        };\n      } :\n      Map;\n\n  // TODO: which browser needs these partial polyfills here?\n\n  // BB7 and webOS need this\n  var isArray = Array.isArray ||\n                (function () {\n                  var toString = {}.toString;\n                  // I once had an engine returning [array Array]\n                  // and I've got scared since!\n                  var s = toString.call([]);\n                  return function (a) {\n                    return toString.call(a) === s;\n                  };\n                }());\n\n  // older WebKit need this\n  var trim = EXPANDO.trim ||\n              function () { return this.replace(/^\\s+|\\s+$/g, ''); };\n\n  // ---------------------------------------------\n  // Shared variables\n  // ---------------------------------------------\n\n  // normalize Firefox issue with template literals\n  var templateObjects, unique;\n  if (FF) {\n    templateObjects = Object.create(null);\n    unique = function (template) {\n      var key = template.join(UID);\n      return templateObjects[key] ||\n            (templateObjects[key] = template);\n    };\n  }\n\n  // use native .append(...childNodes) where available\n  var appendNodes = 'append' in featureFragment ?\n      function (node, childNodes) {\n        node.append.apply(node, childNodes);\n      } :\n      function appendNodes(node, childNodes) {\n        for (var\n          i = 0,\n          length = childNodes.length;\n          i < length; i++\n        ) {\n          node.appendChild(childNodes[i]);\n        }\n      };\n\n  // traps function bind once (useful in destructuring)\n  var bind = hyperHTML.bind;\n  hyperHTML.bind = function () { return bind.apply(hyperHTML, arguments); };\n\n  // returns children or retrieve them in IE/Edge\n  var getChildren = WK ?\n      function (node) {\n        for (var\n          child,\n          children = [],\n          childNodes = node.childNodes,\n          j = 0, i = 0, length = childNodes.length;\n          i < length; i++\n        ) {\n          child = childNodes[i];\n          if (child.nodeType === ELEMENT_NODE)\n            children[j++] = child;\n        }\n        return children;\n      } :\n      function (node) { return node.children; };\n\n  // return the correct node walking through a path\n  // fixes IE/Edge issues with attributes and children (fixes old WebKit too)\n  var getNode = IE || WK ?\n      function (parentNode, path) {\n        for (var name, i = 0, length = path.length; i < length; i++) {\n          name = path[i++];\n          switch (name) {\n            case 'children':\n              parentNode = getChildren(parentNode)[path[i]];\n              break;\n            default:\n              parentNode = parentNode[name][path[i]];\n              break;\n          }\n        }\n        return parentNode;\n      } :\n      function (parentNode, path) {\n        for (var i = 0, length = path.length; i < length; i++) {\n          parentNode = parentNode[path[i++]][path[i]];\n        }\n        return parentNode;\n      };\n\n  // fixes IE problems with comments\n  if (IE) {\n    var IEAttributes;\n    var no = new RegExp('([^\\\\S][a-z]+[a-z0-9_-]*=)([\\'\"])' + UIDC + '\\\\2', 'g');\n    var comments = function ($0, $1, $2) {\n          IEAttributes.push($1.slice(1, -1));\n          return $1 + $2 + UID + $2;\n        };\n  }\n\n  // IE/Edge gotcha with comment nodes\n  var nextElementSibling = IE ?\n    function (node) {\n      node = node.nextSibling;\n      return node && node.nodeType === ELEMENT_NODE ? node : undefined;\n    } :\n    function (node) { return node.nextElementSibling; };\n\n  var previousElementSibling = IE ?\n    function (node) {\n      node = node.previousSibling;\n      return node && node.nodeType === ELEMENT_NODE ? node : undefined;\n    } :\n    function (node) { return node.previousElementSibling; };\n\n  // [element] = {template, updates};\n  var hypers = new $WeakMap;\n\n  // [element] = {template, updates};\n  var wires = new $WeakMap;\n\n  // [template] = {fragment, paths};\n  var templates = new $Map;\n\n  // internal signal to switch adoption\n  var notAdopting = true;\n\n  // IE 11 has problems with cloning templates too\n  // it \"forgets\" empty childNodes\n  var cloneNode = (function () {\n    featureFragment.appendChild(createText(featureFragment, 'g'));\n    featureFragment.appendChild(createText(featureFragment, ''));\n    return featureFragment.cloneNode(true).childNodes.length === 1 ?\n      function (node) {\n        for (var\n          clone = node.cloneNode(),\n          childNodes = node.childNodes || [],\n          i = 0, length = childNodes.length;\n          i < length; i++\n        ) {\n          clone.appendChild(cloneNode(childNodes[i]));\n        }\n        return clone;\n      } :\n      function (fragment) {\n        return fragment.cloneNode(true);\n      };\n  }());\n\n  // ---------------------------------------------\n  // Template related utilities\n  // ---------------------------------------------\n\n  // given a unique template object\n  // create, parse, and store retrieved info\n  function createTemplate(template) {\n    var paths = [];\n    var html = template.join(UIDC);\n    if (IE) {\n      IEAttributes = [];\n      html = html.replace(no, comments);\n    }\n    var fragment = createFragment(this, html);\n    var info = {fragment: fragment, paths: paths};\n    commentsSeeker(fragment, paths);\n    templates.set(template, info);\n    return info;\n  }\n\n  // given a generic node, returns a path capable\n  // of retrieving such path back again.\n  // TODO: worth passing the index when available ?\n  function createPath(node) {\n    var path = [];\n    var parentNode;\n    switch(node.nodeType) {\n      case ELEMENT_NODE:\n      case DOCUMENT_FRAGMENT_NODE:\n        parentNode = node;\n        break;\n      case TEXT_NODE:\n      case COMMENT_NODE:\n        parentNode = node.parentNode;\n        path.unshift(\n          'childNodes',\n          path.indexOf.call(parentNode.childNodes, node)\n        );\n        break;\n      case ATTRIBUTE_NODE:\n      default: // jsdom here does not provide a nodeType 2 ...\n        parentNode = node.ownerElement;\n        path.unshift('attributes', node.name);\n        break;\n    }\n    for (\n      node = parentNode;\n      parentNode = parentNode.parentNode;\n      node = parentNode\n    ) {\n      path.unshift('children', path.indexOf.call(getChildren(parentNode), node));\n    }\n    return path;\n  }\n\n  // given a root node and a list of paths\n  // creates an array of updates to invoke\n  // whenever the next interpolation happens\n  function createUpdates(fragment, paths) {\n    for (var\n      info, target,\n      updates = [],\n      removeAttributes = [],\n      i = 0, length = paths.length;\n      i < length; i++\n    ) {\n      info = paths[i];\n      target = getNode(fragment, info.path);\n      if (target.nodeType === DOCUMENT_FRAGMENT_NODE) {\n        removeNodeList(target.childNodes, 0);\n        target = this;\n      }\n      updates[i] = setContent(info.type, target, removeAttributes, []);\n    }\n    removeAttributeList(removeAttributes);\n    return updates;\n  }\n\n  // like createUpdates but for nodes with already a content\n  function discoverUpdates(fragment, paths) {\n    for (var\n      info, childNodes,\n      updates = [],\n      removeAttributes = [],\n      i = 0, length = paths.length;\n      i < length; i++\n    ) {\n      childNodes = [];\n      info = paths[i];\n      updates[i] = setContent(\n        info.type,\n        discoverNode(this, fragment, info, childNodes),\n        removeAttributes,\n        childNodes\n      );\n    }\n    removeAttributeList(removeAttributes);\n    return updates;\n  }\n\n  // invokes each update function passing interpolated value\n  function update() {\n    for (var i = 1, length = arguments.length; i < length; i++) {\n      this[i - 1](arguments[i]);\n    }\n  }\n\n  // create a template, if unknown\n  // upgrade a node to use such template for future updates\n  function upgrade(template) {\n    if (FF) template = unique(template);\n    var updates;\n    var info =  templates.get(template) ||\n                createTemplate.call(this, template);\n    if (notAdopting) {\n      var fragment = cloneNode(info.fragment);\n      updates = createUpdates.call(this, fragment, info.paths);\n      resetAndPopulate(this, fragment);\n    } else {\n      updates = discoverUpdates.call(this, info.fragment, info.paths);\n    }\n    return {template: template, updates: updates};\n  }\n\n  // ---------------------------------------------\n  // Wires\n  // ---------------------------------------------\n\n  // create a new wire for generic DOM content\n  function wireContent(type) {\n    var adopter, content, container, fragment, render, setup, template;\n\n    function before(document) {\n      fragment = createDocumentFragment(document);\n      container = type === 'svg' ?\n        document.createElementNS(SVG_NAMESPACE, 'svg') :\n        fragment;\n      render = hyperHTML.bind(container);\n    }\n\n    function after() {\n      if (setup) {\n        setup = false;\n        if (type === 'svg') {\n          appendNodes(fragment, slice.call(container.childNodes));\n        }\n        content = createContent(fragment);\n      }\n      return content;\n    }\n\n    return type === 'adopt' ?\n      function adopt(statics) {\n        var args = arguments;\n        if (FF) statics = unique(statics);\n        if (template !== statics) {\n          setup = true;\n          template = statics;\n          adopter = function (parentNode, children, i) {\n            if (setup) {\n              if (i < children.length) {\n                container = children[i];\n                fragment = {\n                  ownerDocument: container.ownerDocument,\n                  childNodes: [container],\n                  children: [container]\n                };\n                render = hyperHTML.adopt(fragment);\n              } else {\n                if (OWNER_SVG_ELEMENT in parentNode) type = 'svg';\n                before(parentNode.ownerDocument);\n              }\n            }\n            render.apply(null, args);\n            return after();\n          };\n        }\n        return adopter;\n      } :\n      function update(statics) {\n        if (FF) statics = unique(statics);\n        if (template !== statics) {\n          setup = true;\n          template = statics;\n          before(hyperHTML.document);\n        }\n        render.apply(null, arguments);\n        return after();\n      };\n  }\n\n  // setup a weak reference if needed and return a wire by ID\n  function wireWeakly(obj, type) {\n    var wire = wires.get(obj);\n    var i = type.indexOf(':');\n    var id = type;\n    if (-1 < i) {\n      id = type.slice(i + 1);\n      type = type.slice(0, i) || 'html';\n    }\n    if (!wire) {\n      wire = {};\n      wires.set(obj, wire);\n    }\n    return wire[id] || (wire[id] = wireContent(type));\n  }\n\n  // ---------------------------------------------\n  // ‚ö°Ô∏è Ô∏èÔ∏èThe End ‚û∞\n  // ---------------------------------------------\n  return hyperHTML;\n\n}(document));\n\n// umd.KISS\ntry { module.exports = hyperHTML; } catch(o_O) {}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/hyperhtml/hyperhtml.js\n// module id = 4\n// module chunks = 0","'use strict';\n\nimport HyperHTMLElement from 'hyperhtml-element';\nimport { Observable} from 'rxjs-es/Observable';\nimport 'rxjs-es/add/observable/fromEvent';\nimport 'rxjs-es/add/operator/map';\n\nclass XButton extends HyperHTMLElement {\n\n  created(){\n    this.attachShadow({mode: 'open'});\n    this.render();\n  }\n\n  render(){\n    return this.html`<button><slot></slot></button>`;\n  }\n\n\n  connectedCallback(){\n    Observable.fromEvent(this, 'click')\n      .map(evt => {\n        console.log(evt);\n        return { x: evt.clientX , y: evt.clientY }\n      })\n      .forEach(data => console.log(JSON.stringify(data)));\n  }\n\n  onclick(e) {\n    console.log(this, 'click', e.target);\n  }\n\n}\n\nXButton.define('x-button');\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/components/x-button.js\n// module id = 5\n// module chunks = 0","let objectTypes = {\n    'boolean': false,\n    'function': true,\n    'object': true,\n    'number': false,\n    'string': false,\n    'undefined': false\n};\nexport let root = (objectTypes[typeof self] && self) || (objectTypes[typeof window] && window);\nlet freeGlobal = objectTypes[typeof global] && global;\nif (freeGlobal && (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal)) {\n    root = freeGlobal;\n}\n//# sourceMappingURL=root.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs-es/util/root.js\n// module id = 6\n// module chunks = 0","export function isFunction(x) {\n    return typeof x === 'function';\n}\n//# sourceMappingURL=isFunction.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs-es/util/isFunction.js\n// module id = 7\n// module chunks = 0","// typeof any so that it we don't have to cast when comparing a result to the error object\nexport var errorObject = { e: {} };\n//# sourceMappingURL=errorObject.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs-es/util/errorObject.js\n// module id = 8\n// module chunks = 0","import { root } from '../util/root';\nconst Symbol = root.Symbol;\nexport const $$rxSubscriber = (typeof Symbol === 'function' && typeof Symbol.for === 'function') ?\n    Symbol.for('rxSubscriber') : '@@rxSubscriber';\n//# sourceMappingURL=rxSubscriber.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs-es/symbol/rxSubscriber.js\n// module id = 9\n// module chunks = 0","import { root } from './util/root';\nimport { toSubscriber } from './util/toSubscriber';\nimport { $$observable } from './symbol/observable';\n/**\n * A representation of any set of values over any amount of time. This the most basic building block\n * of RxJS.\n *\n * @class Observable<T>\n */\nexport class Observable {\n    /**\n     * @constructor\n     * @param {Function} subscribe the function that is  called when the Observable is\n     * initially subscribed to. This function is given a Subscriber, to which new values\n     * can be `next`ed, or an `error` method can be called to raise an error, or\n     * `complete` can be called to notify of a successful completion.\n     */\n    constructor(subscribe) {\n        this._isScalar = false;\n        if (subscribe) {\n            this._subscribe = subscribe;\n        }\n    }\n    /**\n     * Creates a new Observable, with this Observable as the source, and the passed\n     * operator defined as the new observable's operator.\n     * @method lift\n     * @param {Operator} operator the operator defining the operation to take on the observable\n     * @return {Observable} a new observable with the Operator applied\n     */\n    lift(operator) {\n        const observable = new Observable();\n        observable.source = this;\n        observable.operator = operator;\n        return observable;\n    }\n    /**\n     * Registers handlers for handling emitted values, error and completions from the observable, and\n     *  executes the observable's subscriber function, which will take action to set up the underlying data stream\n     * @method subscribe\n     * @param {PartialObserver|Function} observerOrNext (optional) either an observer defining all functions to be called,\n     *  or the first of three possible handlers, which is the handler for each value emitted from the observable.\n     * @param {Function} error (optional) a handler for a terminal event resulting from an error. If no error handler is provided,\n     *  the error will be thrown as unhandled\n     * @param {Function} complete (optional) a handler for a terminal event resulting from successful completion.\n     * @return {ISubscription} a subscription reference to the registered handlers\n     */\n    subscribe(observerOrNext, error, complete) {\n        const { operator } = this;\n        const sink = toSubscriber(observerOrNext, error, complete);\n        if (operator) {\n            operator.call(sink, this);\n        }\n        else {\n            sink.add(this._subscribe(sink));\n        }\n        if (sink.syncErrorThrowable) {\n            sink.syncErrorThrowable = false;\n            if (sink.syncErrorThrown) {\n                throw sink.syncErrorValue;\n            }\n        }\n        return sink;\n    }\n    /**\n     * @method forEach\n     * @param {Function} next a handler for each value emitted by the observable\n     * @param {PromiseConstructor} [PromiseCtor] a constructor function used to instantiate the Promise\n     * @return {Promise} a promise that either resolves on observable completion or\n     *  rejects with the handled error\n     */\n    forEach(next, PromiseCtor) {\n        if (!PromiseCtor) {\n            if (root.Rx && root.Rx.config && root.Rx.config.Promise) {\n                PromiseCtor = root.Rx.config.Promise;\n            }\n            else if (root.Promise) {\n                PromiseCtor = root.Promise;\n            }\n        }\n        if (!PromiseCtor) {\n            throw new Error('no Promise impl found');\n        }\n        return new PromiseCtor((resolve, reject) => {\n            const subscription = this.subscribe((value) => {\n                if (subscription) {\n                    // if there is a subscription, then we can surmise\n                    // the next handling is asynchronous. Any errors thrown\n                    // need to be rejected explicitly and unsubscribe must be\n                    // called manually\n                    try {\n                        next(value);\n                    }\n                    catch (err) {\n                        reject(err);\n                        subscription.unsubscribe();\n                    }\n                }\n                else {\n                    // if there is NO subscription, then we're getting a nexted\n                    // value synchronously during subscription. We can just call it.\n                    // If it errors, Observable's `subscribe` will ensure the\n                    // unsubscription logic is called, then synchronously rethrow the error.\n                    // After that, Promise will trap the error and send it\n                    // down the rejection path.\n                    next(value);\n                }\n            }, reject, resolve);\n        });\n    }\n    _subscribe(subscriber) {\n        return this.source.subscribe(subscriber);\n    }\n    /**\n     * An interop point defined by the es7-observable spec https://github.com/zenparsing/es-observable\n     * @method Symbol.observable\n     * @return {Observable} this instance of the observable\n     */\n    [$$observable]() {\n        return this;\n    }\n}\n// HACK: Since TypeScript inherits static properties too, we have to\n// fight against TypeScript here so Subject can have a different static create signature\n/**\n * Creates a new cold Observable by calling the Observable constructor\n * @static true\n * @owner Observable\n * @method create\n * @param {Function} subscribe? the subscriber function to be passed to the Observable constructor\n * @return {Observable} a new cold observable\n */\nObservable.create = (subscribe) => {\n    return new Observable(subscribe);\n};\n//# sourceMappingURL=Observable.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs-es/Observable.js\n// module id = 10\n// module chunks = 0","var g;\r\n\r\n// This works in non-strict mode\r\ng = (function() {\r\n\treturn this;\r\n})();\r\n\r\ntry {\r\n\t// This works if eval is allowed (see CSP)\r\n\tg = g || Function(\"return this\")() || (1,eval)(\"this\");\r\n} catch(e) {\r\n\t// This works if the window reference is available\r\n\tif(typeof window === \"object\")\r\n\t\tg = window;\r\n}\r\n\r\n// g can still be undefined, but nothing to do about it...\r\n// We return undefined, instead of nothing here, so it's\r\n// easier to handle this case. if(!global) { ...}\r\n\r\nmodule.exports = g;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// (webpack)/buildin/global.js\n// module id = 11\n// module chunks = 0","import { Subscriber } from '../Subscriber';\nimport { $$rxSubscriber } from '../symbol/rxSubscriber';\nexport function toSubscriber(nextOrObserver, error, complete) {\n    if (nextOrObserver) {\n        if (nextOrObserver instanceof Subscriber) {\n            return nextOrObserver;\n        }\n        if (nextOrObserver[$$rxSubscriber]) {\n            return nextOrObserver[$$rxSubscriber]();\n        }\n    }\n    if (!nextOrObserver && !error && !complete) {\n        return new Subscriber();\n    }\n    return new Subscriber(nextOrObserver, error, complete);\n}\n//# sourceMappingURL=toSubscriber.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs-es/util/toSubscriber.js\n// module id = 12\n// module chunks = 0","import { isFunction } from './util/isFunction';\nimport { Subscription } from './Subscription';\nimport { empty as emptyObserver } from './Observer';\nimport { $$rxSubscriber } from './symbol/rxSubscriber';\n/**\n * Implements the {@link Observer} interface and extends the\n * {@link Subscription} class. While the {@link Observer} is the public API for\n * consuming the values of an {@link Observable}, all Observers get converted to\n * a Subscriber, in order to provide Subscription-like capabilities such as\n * `unsubscribe`. Subscriber is a common type in RxJS, and crucial for\n * implementing operators, but it is rarely used as a public API.\n *\n * @class Subscriber<T>\n */\nexport class Subscriber extends Subscription {\n    /**\n     * @param {Observer|function(value: T): void} [destinationOrNext] A partially\n     * defined Observer or a `next` callback function.\n     * @param {function(e: ?any): void} [error] The `error` callback of an\n     * Observer.\n     * @param {function(): void} [complete] The `complete` callback of an\n     * Observer.\n     */\n    constructor(destinationOrNext, error, complete) {\n        super();\n        this.syncErrorValue = null;\n        this.syncErrorThrown = false;\n        this.syncErrorThrowable = false;\n        this.isStopped = false;\n        switch (arguments.length) {\n            case 0:\n                this.destination = emptyObserver;\n                break;\n            case 1:\n                if (!destinationOrNext) {\n                    this.destination = emptyObserver;\n                    break;\n                }\n                if (typeof destinationOrNext === 'object') {\n                    if (destinationOrNext instanceof Subscriber) {\n                        this.destination = destinationOrNext;\n                        this.destination.add(this);\n                    }\n                    else {\n                        this.syncErrorThrowable = true;\n                        this.destination = new SafeSubscriber(this, destinationOrNext);\n                    }\n                    break;\n                }\n            default:\n                this.syncErrorThrowable = true;\n                this.destination = new SafeSubscriber(this, destinationOrNext, error, complete);\n                break;\n        }\n    }\n    [$$rxSubscriber]() { return this; }\n    /**\n     * A static factory for a Subscriber, given a (potentially partial) definition\n     * of an Observer.\n     * @param {function(x: ?T): void} [next] The `next` callback of an Observer.\n     * @param {function(e: ?any): void} [error] The `error` callback of an\n     * Observer.\n     * @param {function(): void} [complete] The `complete` callback of an\n     * Observer.\n     * @return {Subscriber<T>} A Subscriber wrapping the (partially defined)\n     * Observer represented by the given arguments.\n     */\n    static create(next, error, complete) {\n        const subscriber = new Subscriber(next, error, complete);\n        subscriber.syncErrorThrowable = false;\n        return subscriber;\n    }\n    /**\n     * The {@link Observer} callback to receive notifications of type `next` from\n     * the Observable, with a value. The Observable may call this method 0 or more\n     * times.\n     * @param {T} [value] The `next` value.\n     * @return {void}\n     */\n    next(value) {\n        if (!this.isStopped) {\n            this._next(value);\n        }\n    }\n    /**\n     * The {@link Observer} callback to receive notifications of type `error` from\n     * the Observable, with an attached {@link Error}. Notifies the Observer that\n     * the Observable has experienced an error condition.\n     * @param {any} [err] The `error` exception.\n     * @return {void}\n     */\n    error(err) {\n        if (!this.isStopped) {\n            this.isStopped = true;\n            this._error(err);\n        }\n    }\n    /**\n     * The {@link Observer} callback to receive a valueless notification of type\n     * `complete` from the Observable. Notifies the Observer that the Observable\n     * has finished sending push-based notifications.\n     * @return {void}\n     */\n    complete() {\n        if (!this.isStopped) {\n            this.isStopped = true;\n            this._complete();\n        }\n    }\n    unsubscribe() {\n        if (this.closed) {\n            return;\n        }\n        this.isStopped = true;\n        super.unsubscribe();\n    }\n    _next(value) {\n        this.destination.next(value);\n    }\n    _error(err) {\n        this.destination.error(err);\n        this.unsubscribe();\n    }\n    _complete() {\n        this.destination.complete();\n        this.unsubscribe();\n    }\n}\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass SafeSubscriber extends Subscriber {\n    constructor(_parent, observerOrNext, error, complete) {\n        super();\n        this._parent = _parent;\n        let next;\n        let context = this;\n        if (isFunction(observerOrNext)) {\n            next = observerOrNext;\n        }\n        else if (observerOrNext) {\n            context = observerOrNext;\n            next = observerOrNext.next;\n            error = observerOrNext.error;\n            complete = observerOrNext.complete;\n            if (isFunction(context.unsubscribe)) {\n                this.add(context.unsubscribe.bind(context));\n            }\n            context.unsubscribe = this.unsubscribe.bind(this);\n        }\n        this._context = context;\n        this._next = next;\n        this._error = error;\n        this._complete = complete;\n    }\n    next(value) {\n        if (!this.isStopped && this._next) {\n            const { _parent } = this;\n            if (!_parent.syncErrorThrowable) {\n                this.__tryOrUnsub(this._next, value);\n            }\n            else if (this.__tryOrSetError(_parent, this._next, value)) {\n                this.unsubscribe();\n            }\n        }\n    }\n    error(err) {\n        if (!this.isStopped) {\n            const { _parent } = this;\n            if (this._error) {\n                if (!_parent.syncErrorThrowable) {\n                    this.__tryOrUnsub(this._error, err);\n                    this.unsubscribe();\n                }\n                else {\n                    this.__tryOrSetError(_parent, this._error, err);\n                    this.unsubscribe();\n                }\n            }\n            else if (!_parent.syncErrorThrowable) {\n                this.unsubscribe();\n                throw err;\n            }\n            else {\n                _parent.syncErrorValue = err;\n                _parent.syncErrorThrown = true;\n                this.unsubscribe();\n            }\n        }\n    }\n    complete() {\n        if (!this.isStopped) {\n            const { _parent } = this;\n            if (this._complete) {\n                if (!_parent.syncErrorThrowable) {\n                    this.__tryOrUnsub(this._complete);\n                    this.unsubscribe();\n                }\n                else {\n                    this.__tryOrSetError(_parent, this._complete);\n                    this.unsubscribe();\n                }\n            }\n            else {\n                this.unsubscribe();\n            }\n        }\n    }\n    __tryOrUnsub(fn, value) {\n        try {\n            fn.call(this._context, value);\n        }\n        catch (err) {\n            this.unsubscribe();\n            throw err;\n        }\n    }\n    __tryOrSetError(parent, fn, value) {\n        try {\n            fn.call(this._context, value);\n        }\n        catch (err) {\n            parent.syncErrorValue = err;\n            parent.syncErrorThrown = true;\n            return true;\n        }\n        return false;\n    }\n    _unsubscribe() {\n        const { _parent } = this;\n        this._context = null;\n        this._parent = null;\n        _parent.unsubscribe();\n    }\n}\n//# sourceMappingURL=Subscriber.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs-es/Subscriber.js\n// module id = 13\n// module chunks = 0","import { isArray } from './util/isArray';\nimport { isObject } from './util/isObject';\nimport { isFunction } from './util/isFunction';\nimport { tryCatch } from './util/tryCatch';\nimport { errorObject } from './util/errorObject';\nimport { UnsubscriptionError } from './util/UnsubscriptionError';\n/**\n * Represents a disposable resource, such as the execution of an Observable. A\n * Subscription has one important method, `unsubscribe`, that takes no argument\n * and just disposes the resource held by the subscription.\n *\n * Additionally, subscriptions may be grouped together through the `add()`\n * method, which will attach a child Subscription to the current Subscription.\n * When a Subscription is unsubscribed, all its children (and its grandchildren)\n * will be unsubscribed as well.\n *\n * @class Subscription\n */\nexport class Subscription {\n    /**\n     * @param {function(): void} [unsubscribe] A function describing how to\n     * perform the disposal of resources when the `unsubscribe` method is called.\n     */\n    constructor(unsubscribe) {\n        /**\n         * A flag to indicate whether this Subscription has already been unsubscribed.\n         * @type {boolean}\n         */\n        this.closed = false;\n        if (unsubscribe) {\n            this._unsubscribe = unsubscribe;\n        }\n    }\n    /**\n     * Disposes the resources held by the subscription. May, for instance, cancel\n     * an ongoing Observable execution or cancel any other type of work that\n     * started when the Subscription was created.\n     * @return {void}\n     */\n    unsubscribe() {\n        let hasErrors = false;\n        let errors;\n        if (this.closed) {\n            return;\n        }\n        this.closed = true;\n        const { _unsubscribe, _subscriptions } = this;\n        this._subscriptions = null;\n        if (isFunction(_unsubscribe)) {\n            let trial = tryCatch(_unsubscribe).call(this);\n            if (trial === errorObject) {\n                hasErrors = true;\n                (errors = errors || []).push(errorObject.e);\n            }\n        }\n        if (isArray(_subscriptions)) {\n            let index = -1;\n            const len = _subscriptions.length;\n            while (++index < len) {\n                const sub = _subscriptions[index];\n                if (isObject(sub)) {\n                    let trial = tryCatch(sub.unsubscribe).call(sub);\n                    if (trial === errorObject) {\n                        hasErrors = true;\n                        errors = errors || [];\n                        let err = errorObject.e;\n                        if (err instanceof UnsubscriptionError) {\n                            errors = errors.concat(err.errors);\n                        }\n                        else {\n                            errors.push(err);\n                        }\n                    }\n                }\n            }\n        }\n        if (hasErrors) {\n            throw new UnsubscriptionError(errors);\n        }\n    }\n    /**\n     * Adds a tear down to be called during the unsubscribe() of this\n     * Subscription.\n     *\n     * If the tear down being added is a subscription that is already\n     * unsubscribed, is the same reference `add` is being called on, or is\n     * `Subscription.EMPTY`, it will not be added.\n     *\n     * If this subscription is already in an `closed` state, the passed\n     * tear down logic will be executed immediately.\n     *\n     * @param {TeardownLogic} teardown The additional logic to execute on\n     * teardown.\n     * @return {Subscription} Returns the Subscription used or created to be\n     * added to the inner subscriptions list. This Subscription can be used with\n     * `remove()` to remove the passed teardown logic from the inner subscriptions\n     * list.\n     */\n    add(teardown) {\n        if (!teardown || (teardown === Subscription.EMPTY)) {\n            return Subscription.EMPTY;\n        }\n        if (teardown === this) {\n            return this;\n        }\n        let sub = teardown;\n        switch (typeof teardown) {\n            case 'function':\n                sub = new Subscription(teardown);\n            case 'object':\n                if (sub.closed || typeof sub.unsubscribe !== 'function') {\n                    break;\n                }\n                else if (this.closed) {\n                    sub.unsubscribe();\n                }\n                else {\n                    (this._subscriptions || (this._subscriptions = [])).push(sub);\n                }\n                break;\n            default:\n                throw new Error('unrecognized teardown ' + teardown + ' added to Subscription.');\n        }\n        return sub;\n    }\n    /**\n     * Removes a Subscription from the internal list of subscriptions that will\n     * unsubscribe during the unsubscribe process of this Subscription.\n     * @param {Subscription} subscription The subscription to remove.\n     * @return {void}\n     */\n    remove(subscription) {\n        // HACK: This might be redundant because of the logic in `add()`\n        if (subscription == null || (subscription === this) || (subscription === Subscription.EMPTY)) {\n            return;\n        }\n        const subscriptions = this._subscriptions;\n        if (subscriptions) {\n            const subscriptionIndex = subscriptions.indexOf(subscription);\n            if (subscriptionIndex !== -1) {\n                subscriptions.splice(subscriptionIndex, 1);\n            }\n        }\n    }\n}\nSubscription.EMPTY = (function (empty) {\n    empty.closed = true;\n    return empty;\n}(new Subscription()));\n//# sourceMappingURL=Subscription.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs-es/Subscription.js\n// module id = 14\n// module chunks = 0","export const isArray = Array.isArray || ((x) => x && typeof x.length === 'number');\n//# sourceMappingURL=isArray.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs-es/util/isArray.js\n// module id = 15\n// module chunks = 0","export function isObject(x) {\n    return x != null && typeof x === 'object';\n}\n//# sourceMappingURL=isObject.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs-es/util/isObject.js\n// module id = 16\n// module chunks = 0","import { errorObject } from './errorObject';\nlet tryCatchTarget;\nfunction tryCatcher() {\n    try {\n        return tryCatchTarget.apply(this, arguments);\n    }\n    catch (e) {\n        errorObject.e = e;\n        return errorObject;\n    }\n}\nexport function tryCatch(fn) {\n    tryCatchTarget = fn;\n    return tryCatcher;\n}\n;\n//# sourceMappingURL=tryCatch.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs-es/util/tryCatch.js\n// module id = 17\n// module chunks = 0","/**\n * An error thrown when one or more errors have occurred during the\n * `unsubscribe` of a {@link Subscription}.\n */\nexport class UnsubscriptionError extends Error {\n    constructor(errors) {\n        super();\n        this.errors = errors;\n        const err = Error.call(this, errors ?\n            `${errors.length} errors occurred during unsubscription:\n  ${errors.map((err, i) => `${i + 1}) ${err.toString()}`).join('\\n  ')}` : '');\n        this.name = err.name = 'UnsubscriptionError';\n        this.stack = err.stack;\n        this.message = err.message;\n    }\n}\n//# sourceMappingURL=UnsubscriptionError.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs-es/util/UnsubscriptionError.js\n// module id = 18\n// module chunks = 0","export const empty = {\n    closed: true,\n    next(value) { },\n    error(err) { throw err; },\n    complete() { }\n};\n//# sourceMappingURL=Observer.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs-es/Observer.js\n// module id = 19\n// module chunks = 0","import { root } from '../util/root';\nexport function getSymbolObservable(context) {\n    let $$observable;\n    let Symbol = context.Symbol;\n    if (typeof Symbol === 'function') {\n        if (Symbol.observable) {\n            $$observable = Symbol.observable;\n        }\n        else {\n            $$observable = Symbol('observable');\n            Symbol.observable = $$observable;\n        }\n    }\n    else {\n        $$observable = '@@observable';\n    }\n    return $$observable;\n}\nexport const $$observable = getSymbolObservable(root);\n//# sourceMappingURL=observable.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs-es/symbol/observable.js\n// module id = 20\n// module chunks = 0","import { Observable } from '../../Observable';\nimport { fromEvent as staticFromEvent } from '../../observable/fromEvent';\nObservable.fromEvent = staticFromEvent;\n//# sourceMappingURL=fromEvent.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs-es/add/observable/fromEvent.js\n// module id = 21\n// module chunks = 0","import { FromEventObservable } from './FromEventObservable';\nexport const fromEvent = FromEventObservable.create;\n//# sourceMappingURL=fromEvent.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs-es/observable/fromEvent.js\n// module id = 22\n// module chunks = 0","import { Observable } from '../Observable';\nimport { tryCatch } from '../util/tryCatch';\nimport { isFunction } from '../util/isFunction';\nimport { errorObject } from '../util/errorObject';\nimport { Subscription } from '../Subscription';\nfunction isNodeStyleEventEmmitter(sourceObj) {\n    return !!sourceObj && typeof sourceObj.addListener === 'function' && typeof sourceObj.removeListener === 'function';\n}\nfunction isJQueryStyleEventEmitter(sourceObj) {\n    return !!sourceObj && typeof sourceObj.on === 'function' && typeof sourceObj.off === 'function';\n}\nfunction isNodeList(sourceObj) {\n    return !!sourceObj && sourceObj.toString() === '[object NodeList]';\n}\nfunction isHTMLCollection(sourceObj) {\n    return !!sourceObj && sourceObj.toString() === '[object HTMLCollection]';\n}\nfunction isEventTarget(sourceObj) {\n    return !!sourceObj && typeof sourceObj.addEventListener === 'function' && typeof sourceObj.removeEventListener === 'function';\n}\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n */\nexport class FromEventObservable extends Observable {\n    constructor(sourceObj, eventName, selector, options) {\n        super();\n        this.sourceObj = sourceObj;\n        this.eventName = eventName;\n        this.selector = selector;\n        this.options = options;\n    }\n    /* tslint:enable:max-line-length */\n    /**\n     * Creates an Observable that emits events of a specific type coming from the\n     * given event target.\n     *\n     * <span class=\"informal\">Creates an Observable from DOM events, or Node\n     * EventEmitter events or others.</span>\n     *\n     * <img src=\"./img/fromEvent.png\" width=\"100%\">\n     *\n     * Creates an Observable by attaching an event listener to an \"event target\",\n     * which may be an object with `addEventListener` and `removeEventListener`,\n     * a Node.js EventEmitter, a jQuery style EventEmitter, a NodeList from the\n     * DOM, or an HTMLCollection from the DOM. The event handler is attached when\n     * the output Observable is subscribed, and removed when the Subscription is\n     * unsubscribed.\n     *\n     * @example <caption>Emits clicks happening on the DOM document</caption>\n     * var clicks = Rx.Observable.fromEvent(document, 'click');\n     * clicks.subscribe(x => console.log(x));\n     *\n     * @see {@link from}\n     * @see {@link fromEventPattern}\n     *\n     * @param {EventTargetLike} target The DOMElement, event target, Node.js\n     * EventEmitter, NodeList or HTMLCollection to attach the event handler to.\n     * @param {string} eventName The event name of interest, being emitted by the\n     * `target`.\n     * @parm {EventListenerOptions} [options] Options to pass through to addEventListener\n     * @param {SelectorMethodSignature<T>} [selector] An optional function to\n     * post-process results. It takes the arguments from the event handler and\n     * should return a single value.\n     * @return {Observable<T>}\n     * @static true\n     * @name fromEvent\n     * @owner Observable\n     */\n    static create(target, eventName, options, selector) {\n        if (isFunction(options)) {\n            selector = options;\n            options = undefined;\n        }\n        return new FromEventObservable(target, eventName, selector, options);\n    }\n    static setupSubscription(sourceObj, eventName, handler, subscriber, options) {\n        let unsubscribe;\n        if (isNodeList(sourceObj) || isHTMLCollection(sourceObj)) {\n            for (let i = 0, len = sourceObj.length; i < len; i++) {\n                FromEventObservable.setupSubscription(sourceObj[i], eventName, handler, subscriber, options);\n            }\n        }\n        else if (isEventTarget(sourceObj)) {\n            const source = sourceObj;\n            sourceObj.addEventListener(eventName, handler, options);\n            unsubscribe = () => source.removeEventListener(eventName, handler);\n        }\n        else if (isJQueryStyleEventEmitter(sourceObj)) {\n            const source = sourceObj;\n            sourceObj.on(eventName, handler);\n            unsubscribe = () => source.off(eventName, handler);\n        }\n        else if (isNodeStyleEventEmmitter(sourceObj)) {\n            const source = sourceObj;\n            sourceObj.addListener(eventName, handler);\n            unsubscribe = () => source.removeListener(eventName, handler);\n        }\n        subscriber.add(new Subscription(unsubscribe));\n    }\n    _subscribe(subscriber) {\n        const sourceObj = this.sourceObj;\n        const eventName = this.eventName;\n        const options = this.options;\n        const selector = this.selector;\n        let handler = selector ? (...args) => {\n            let result = tryCatch(selector)(...args);\n            if (result === errorObject) {\n                subscriber.error(errorObject.e);\n            }\n            else {\n                subscriber.next(result);\n            }\n        } : (e) => subscriber.next(e);\n        FromEventObservable.setupSubscription(sourceObj, eventName, handler, subscriber, options);\n    }\n}\n//# sourceMappingURL=FromEventObservable.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs-es/observable/FromEventObservable.js\n// module id = 23\n// module chunks = 0","import { Observable } from '../../Observable';\nimport { map } from '../../operator/map';\nObservable.prototype.map = map;\n//# sourceMappingURL=map.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs-es/add/operator/map.js\n// module id = 24\n// module chunks = 0","import { Subscriber } from '../Subscriber';\n/**\n * Applies a given `project` function to each value emitted by the source\n * Observable, and emits the resulting values as an Observable.\n *\n * <span class=\"informal\">Like [Array.prototype.map()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map),\n * it passes each source value through a transformation function to get\n * corresponding output values.</span>\n *\n * <img src=\"./img/map.png\" width=\"100%\">\n *\n * Similar to the well known `Array.prototype.map` function, this operator\n * applies a projection to each value and emits that projection in the output\n * Observable.\n *\n * @example <caption>Map every every click to the clientX position of that click</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var positions = clicks.map(ev => ev.clientX);\n * positions.subscribe(x => console.log(x));\n *\n * @see {@link mapTo}\n * @see {@link pluck}\n *\n * @param {function(value: T, index: number): R} project The function to apply\n * to each `value` emitted by the source Observable. The `index` parameter is\n * the number `i` for the i-th emission that has happened since the\n * subscription, starting from the number `0`.\n * @param {any} [thisArg] An optional argument to define what `this` is in the\n * `project` function.\n * @return {Observable<R>} An Observable that emits the values from the source\n * Observable transformed by the given `project` function.\n * @method map\n * @owner Observable\n */\nexport function map(project, thisArg) {\n    if (typeof project !== 'function') {\n        throw new TypeError('argument is not a function. Are you looking for `mapTo()`?');\n    }\n    return this.lift(new MapOperator(project, thisArg));\n}\nexport class MapOperator {\n    constructor(project, thisArg) {\n        this.project = project;\n        this.thisArg = thisArg;\n    }\n    call(subscriber, source) {\n        return source._subscribe(new MapSubscriber(subscriber, this.project, this.thisArg));\n    }\n}\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass MapSubscriber extends Subscriber {\n    constructor(destination, project, thisArg) {\n        super(destination);\n        this.project = project;\n        this.count = 0;\n        this.thisArg = thisArg || this;\n    }\n    // NOTE: This looks unoptimized, but it's actually purposefully NOT\n    // using try/catch optimizations.\n    _next(value) {\n        let result;\n        try {\n            result = this.project.call(this.thisArg, value, this.count++);\n        }\n        catch (err) {\n            this.destination.error(err);\n            return;\n        }\n        this.destination.next(result);\n    }\n}\n//# sourceMappingURL=map.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs-es/operator/map.js\n// module id = 25\n// module chunks = 0"],"sourceRoot":""}